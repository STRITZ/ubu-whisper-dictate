#!/usr/bin/env python3
"""Simple dictation GUI using whisper.cpp with hotkey support"""

import os
import sys

# Force X11 backend so we can use wmctrl to set always-on-top.
# wl-copy and ydotool still work since they're independent Wayland clients.
os.environ.setdefault('GDK_BACKEND', 'x11')

import gi
import subprocess
import time
import socket
import threading
import select

gi.require_version('Gtk', '4.0')
from gi.repository import Gtk, GLib, Gio

WHISPER_DIR = os.path.expanduser("~/.local/share/whisper.cpp")
MODEL = f"{WHISPER_DIR}/models/ggml-tiny.en.bin"
WHISPER_BIN = f"{WHISPER_DIR}/build/bin/whisper-cli"
AUDIO_FILE = "/tmp/dictation_audio.wav"
YDOTOOL_SOCKET = os.path.expanduser("~/.ydotool_socket")
IPC_SOCKET = "/tmp/whisper-dictate.sock"

# Common whisper hallucinations from silence/noise - filter these out
HALLUCINATIONS = {
    "you", "thank you", "thanks", "bye", "okay", "so", "the", "and",
    "i", "a", "to", "it", "is", "that", "for", "on", "are", "as",
    "you.", "thank you.", "thanks.", "bye.", "okay.",
    "[music]", "[blank_audio]", "(music)", "[silence]",
}

# Terminal app names that need Ctrl+Shift+V
TERMINAL_APPS = {"gnome-terminal-server", "gnome-terminal", "konsole", "xterm",
    "terminator", "tilix", "alacritty", "kitty", "wezterm", "urxvt",
    "xfce4-terminal", "lxterminal", "mate-terminal", "terminology"}


def send_toggle_command():
    """Send toggle command to running instance."""
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(IPC_SOCKET)
        sock.send(b"toggle")
        sock.close()
        return True
    except (socket.error, FileNotFoundError):
        return False


def get_active_window_name():
    """Get active window name using wmctrl or fallback"""
    try:
        result = subprocess.run(
            ["bash", "-c", """
            for wid in $(xdotool search --onlyvisible --name ""); do
                if xprop -id $wid 2>/dev/null | grep -q "_NET_WM_STATE_FOCUSED"; then
                    xdotool getwindowname $wid 2>/dev/null
                    exit 0
                fi
            done
            cat /proc/$(xdotool getactivewindow getwindowpid 2>/dev/null)/comm 2>/dev/null || echo "unknown"
            """],
            capture_output=True, text=True, timeout=2
        )
        return result.stdout.strip() or "unknown"
    except:
        return "unknown"


def is_terminal(window_name):
    """Check if window name suggests a terminal"""
    if not window_name:
        return False
    wl = window_name.lower()
    return any(t in wl for t in TERMINAL_APPS) or "terminal" in wl or "~" in window_name or window_name.endswith("$") or "@" in window_name


class DictationApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.local.whisper-dictate",
                         flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE)
        self.recording = False
        self.record_process = None
        self.window = None
        self.button = None
        self.status_label = None
        self.target_is_terminal = False
        self.ipc_server = None

    def do_command_line(self, command_line):
        args = command_line.get_arguments()

        if "--toggle" in args:
            # Send toggle to running instance
            if send_toggle_command():
                print("Toggle sent to running instance")
                return 0
            else:
                print("No running instance found, starting new one...")

        self.activate()
        return 0

    def do_activate(self):
        if self.window:
            self.window.present()
            return

        # Start IPC server
        self.start_ipc_server()

        self.window = Gtk.ApplicationWindow(application=self)
        self.window.set_title("")
        self.window.set_default_size(120, 140)
        self.window.set_resizable(False)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_halign(Gtk.Align.CENTER)
        box.set_valign(Gtk.Align.CENTER)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        box.set_margin_start(15)
        box.set_margin_end(15)

        self.button = Gtk.Button()
        self.button.set_icon_name("audio-input-microphone-symbolic")
        self.button.add_css_class("circular")
        self.button.set_size_request(70, 70)
        self.button.connect("clicked", self.on_button_clicked)
        box.append(self.button)

        self.status_label = Gtk.Label(label="Ready")
        box.append(self.status_label)

        # Word/Apps toggle (OFF = Terminal mode default, ON = Word/Apps mode)
        toggle_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        toggle_box.set_halign(Gtk.Align.CENTER)
        toggle_label = Gtk.Label(label="Word/Apps")
        toggle_label.add_css_class("dim-label")
        self.word_apps_switch = Gtk.Switch()
        self.word_apps_switch.set_active(False)  # Terminal mode by default
        toggle_box.append(toggle_label)
        toggle_box.append(self.word_apps_switch)
        box.append(toggle_box)

        self.window.set_child(box)

        css_provider = Gtk.CssProvider()
        css = """
            .mic-ready { background: #3584e4; color: white; }
            .mic-ready:hover { background: #1c71d8; }
            .mic-recording { background: #e01b24; color: white; }
            .mic-recording:hover { background: #c01020; }
            .mic-processing { background: #f5c211; color: black; }
            .dim-label { font-size: 10px; color: #888; }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            self.window.get_display(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        self.set_ready_state()
        self.window.present()

        # Set always-on-top after window is fully mapped
        GLib.timeout_add(200, self._set_always_on_top)

        # Start Alt double-tap hotkey listener
        self._start_hotkey_listener()

    def _set_always_on_top(self):
        """Set window as always-on-top using xdotool + wmctrl."""
        try:
            result = subprocess.run(
                ["xdotool", "search", "--pid", str(os.getpid())],
                capture_output=True, text=True, timeout=2
            )
            for wid in result.stdout.strip().split('\n'):
                if wid:
                    subprocess.run(
                        ["wmctrl", "-i", "-r", wid, "-b", "add,above"],
                        check=False, capture_output=True, timeout=2
                    )
        except FileNotFoundError as e:
            print(f"Missing tool for always-on-top: {e}")
        except Exception as e:
            print(f"Could not set always-on-top: {e}")
        return False

    def _start_hotkey_listener(self):
        """Listen for Alt double-tap to toggle recording."""
        try:
            import evdev
            from evdev import ecodes
        except ImportError:
            print("python3-evdev not installed - Alt double-tap hotkey disabled")
            return

        def listener_thread():
            devices = []
            for path in evdev.list_devices():
                try:
                    devices.append(evdev.InputDevice(path))
                except PermissionError:
                    continue

            keyboards = [d for d in devices if ecodes.EV_KEY in d.capabilities()]
            if not keyboards:
                print("No keyboard devices found for hotkey listener")
                return

            last_alt_release = 0
            other_key_pressed = False

            while True:
                try:
                    r, _, _ = select.select(keyboards, [], [])
                    for dev in r:
                        for event in dev.read():
                            if event.type != ecodes.EV_KEY:
                                continue

                            if event.code in (ecodes.KEY_LEFTALT, ecodes.KEY_RIGHTALT):
                                if event.value == 1:  # Key down
                                    other_key_pressed = False
                                elif event.value == 0:  # Key up
                                    now = time.time()
                                    if not other_key_pressed and (now - last_alt_release) < 0.4:
                                        GLib.idle_add(self.toggle_recording)
                                        last_alt_release = 0
                                    else:
                                        last_alt_release = now
                            elif event.value == 1:  # Any other key pressed
                                other_key_pressed = True
                except Exception:
                    break

        thread = threading.Thread(target=listener_thread, daemon=True)
        thread.start()

    def start_ipc_server(self):
        """Start Unix socket server for IPC."""
        # Remove existing socket
        try:
            os.unlink(IPC_SOCKET)
        except OSError:
            pass

        def server_thread():
            server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            server.bind(IPC_SOCKET)
            server.listen(1)
            self.ipc_server = server

            while True:
                try:
                    conn, _ = server.accept()
                    data = conn.recv(1024).decode()
                    conn.close()

                    if data == "toggle":
                        # Schedule toggle on main thread
                        GLib.idle_add(self.toggle_recording)
                except:
                    break

        thread = threading.Thread(target=server_thread, daemon=True)
        thread.start()

    def toggle_recording(self):
        """Toggle recording state (called from IPC)."""
        self.on_button_clicked(None)
        return False

    def set_ready_state(self):
        self.button.remove_css_class("mic-recording")
        self.button.remove_css_class("mic-processing")
        self.button.add_css_class("mic-ready")
        self.button.set_icon_name("audio-input-microphone-symbolic")
        self.button.set_sensitive(True)
        self.status_label.set_text("Ready")
        return False

    def set_recording_state(self):
        self.button.remove_css_class("mic-ready")
        self.button.remove_css_class("mic-processing")
        self.button.add_css_class("mic-recording")
        self.button.set_icon_name("media-record-symbolic")
        self.status_label.set_text("Recording...")

    def set_processing_state(self):
        self.button.remove_css_class("mic-ready")
        self.button.remove_css_class("mic-recording")
        self.button.add_css_class("mic-processing")
        self.button.set_icon_name("emblem-synchronizing-symbolic")
        self.button.set_sensitive(False)
        self.status_label.set_text("Processing...")

    def paste_text(self, text):
        """Copy to clipboard and paste"""
        subprocess.run(["wl-copy", "--", text], check=False)
        subprocess.run(["wl-copy", "--primary", "--", text], check=False)
        time.sleep(0.2)

        env = os.environ.copy()
        env["YDOTOOL_SOCKET"] = YDOTOOL_SOCKET

        # Alt+Tab back
        subprocess.run(["ydotool", "key", "56:1", "15:1", "15:0", "56:0"], env=env)
        time.sleep(0.3)

        # Check switch state - OFF = Terminal mode (default), ON = Word/Apps mode
        if self.word_apps_switch.get_active():
            # Ctrl+V for Word/Apps
            subprocess.run(["ydotool", "key", "29:1", "47:1", "47:0", "29:0"], env=env)
        else:
            # Ctrl+Shift+V for Terminal mode (default)
            subprocess.run(["ydotool", "key", "29:1", "42:1", "47:1", "47:0", "42:0", "29:0"], env=env)

    def on_button_clicked(self, button):
        if not self.recording:
            self.start_recording()
        else:
            self.stop_recording()

    def start_recording(self):
        self.recording = True
        self.set_recording_state()

        self.record_process = subprocess.Popen(
            ["arecord", "-f", "cd", "-t", "wav", "-r", "16000", "-c", "1", AUDIO_FILE],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

    def stop_recording(self):
        self.recording = False
        self.set_processing_state()

        if self.record_process:
            self.record_process.terminate()
            self.record_process.wait()
            self.record_process = None

        GLib.timeout_add(200, self.transcribe)

    def transcribe(self):
        if not os.path.exists(AUDIO_FILE):
            self.set_ready_state()
            return False

        try:
            result = subprocess.run(
                [WHISPER_BIN, "-m", MODEL, "-f", AUDIO_FILE,
                 "--no-timestamps", "-nt", "-np"],
                capture_output=True,
                text=True
            )
            text = result.stdout.strip()

            print(f"Whisper output: '{text}'")

            # Filter out common hallucinations from silence
            if text.lower() in HALLUCINATIONS or len(text) < 3:
                print(f"Filtered hallucination: '{text}'")
                self.status_label.set_text("No speech detected")
                GLib.timeout_add(1500, self.set_ready_state)
                return False

            if text:
                self.paste_text(text)
                self.status_label.set_text("Done!")
                GLib.timeout_add(1500, self.set_ready_state)
            else:
                self.set_ready_state()

        except Exception as e:
            print(f"Error: {e}")
            self.set_ready_state()
        finally:
            if os.path.exists(AUDIO_FILE):
                os.remove(AUDIO_FILE)

        return False


if __name__ == "__main__":
    # Check for --toggle with no running instance
    if "--toggle" in sys.argv and not os.path.exists(IPC_SOCKET):
        print("No running instance. Start the app first.")
        sys.exit(1)

    app = DictationApp()
    app.run(sys.argv)
