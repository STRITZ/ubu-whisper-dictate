#!/usr/bin/env python3
"""Simple dictation GUI using whisper.cpp with hotkey support"""

import os
import sys

# Force X11 backend so we can use wmctrl to set always-on-top.
# wl-copy and ydotool still work since they're independent Wayland clients.
os.environ.setdefault('GDK_BACKEND', 'x11')

import gi
import subprocess
import time
import socket
import threading
import select

gi.require_version('Gtk', '4.0')
from gi.repository import Gtk, GLib, Gio

WHISPER_DIR = os.path.expanduser("~/.local/share/whisper.cpp")
MODEL = f"{WHISPER_DIR}/models/ggml-small.en.bin"
WHISPER_BIN = f"{WHISPER_DIR}/build/bin/whisper-cli"
WHISPER_SERVER = "http://127.0.0.1:8178/inference"
AUDIO_FILE = "/tmp/dictation_audio.wav"
YDOTOOL_SOCKET = os.path.expanduser("~/.ydotool_socket")
IPC_SOCKET = "/tmp/whisper-dictate.sock"

# Common whisper hallucinations from silence/noise - filter these out
HALLUCINATIONS = {
    "you", "thank you", "thanks", "bye", "okay", "so", "the", "and",
    "i", "a", "to", "it", "is", "that", "for", "on", "are", "as",
    "you.", "thank you.", "thanks.", "bye.", "okay.",
    "[music]", "[blank_audio]", "(music)", "[silence]",
}

# Terminal app names that need Ctrl+Shift+V
TERMINAL_APPS = {"gnome-terminal-server", "gnome-terminal", "konsole", "xterm",
    "terminator", "tilix", "alacritty", "kitty", "wezterm", "urxvt",
    "xfce4-terminal", "lxterminal", "mate-terminal", "terminology"}


def send_toggle_command():
    """Send toggle command to running instance."""
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(IPC_SOCKET)
        sock.send(b"toggle")
        sock.close()
        return True
    except (socket.error, FileNotFoundError):
        return False


def get_active_window_name():
    """Get active window name using wmctrl or fallback"""
    try:
        result = subprocess.run(
            ["bash", "-c", """
            for wid in $(xdotool search --onlyvisible --name ""); do
                if xprop -id $wid 2>/dev/null | grep -q "_NET_WM_STATE_FOCUSED"; then
                    xdotool getwindowname $wid 2>/dev/null
                    exit 0
                fi
            done
            cat /proc/$(xdotool getactivewindow getwindowpid 2>/dev/null)/comm 2>/dev/null || echo "unknown"
            """],
            capture_output=True, text=True, timeout=2
        )
        return result.stdout.strip() or "unknown"
    except:
        return "unknown"


def is_terminal(window_name):
    """Check if window name suggests a terminal"""
    if not window_name:
        return False
    wl = window_name.lower()
    return any(t in wl for t in TERMINAL_APPS) or "terminal" in wl or "~" in window_name or window_name.endswith("$") or "@" in window_name


class DictationApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.local.whisper-dictate",
                         flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE)
        self.recording = False
        self.record_process = None
        self.window = None
        self.button = None
        self.status_label = None
        self.target_is_terminal = False
        self.ipc_server = None
        self.hotkey_triggered = False
        self.uinput = None

    def do_command_line(self, command_line):
        args = command_line.get_arguments()

        if "--toggle" in args:
            # Send toggle to running instance
            if send_toggle_command():
                print("Toggle sent to running instance")
                return 0
            else:
                print("No running instance found, starting new one...")

        self.activate()
        return 0

    def do_activate(self):
        if self.window:
            self.window.present()
            return

        # Start IPC server
        self.start_ipc_server()

        self.window = Gtk.ApplicationWindow(application=self)
        self.window.set_title("")
        self.window.set_default_size(300, 380)
        self.window.set_resizable(False)
        self.window.set_decorated(False)

        outer = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        outer.add_css_class("app-container")

        # Drag bar at the top
        drag_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        drag_bar.set_size_request(-1, 36)
        drag_bar.add_css_class("drag-bar")
        drag_icon = Gtk.Image.new_from_icon_name("open-menu-symbolic")
        drag_icon.add_css_class("drag-icon")
        drag_bar.set_halign(Gtk.Align.FILL)
        drag_bar.set_valign(Gtk.Align.START)
        # Center the drag icon
        drag_bar.append(Gtk.Box(hexpand=True))
        drag_bar.append(drag_icon)
        drag_bar.append(Gtk.Box(hexpand=True))

        # Enable dragging on the bar
        drag_gesture = Gtk.GestureDrag()
        drag_gesture.connect("drag-begin", self._on_drag_begin)
        drag_gesture.connect("drag-update", self._on_drag_update)
        drag_bar.add_controller(drag_gesture)

        outer.append(drag_bar)

        # Main content
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        box.set_halign(Gtk.Align.CENTER)
        box.set_valign(Gtk.Align.CENTER)
        box.set_vexpand(True)
        box.set_margin_top(20)
        box.set_margin_bottom(20)
        box.set_margin_start(30)
        box.set_margin_end(30)

        self.button = Gtk.Button()
        self.button.set_icon_name("audio-input-microphone-symbolic")
        self.button.add_css_class("circular")
        self.button.add_css_class("mic-button")
        self.button.set_size_request(180, 180)
        self.button.set_sensitive(False)
        box.append(self.button)

        self.status_label = Gtk.Label(label="Ready")
        self.status_label.add_css_class("status-label")
        box.append(self.status_label)

        close_button = Gtk.Button(label="Close")
        close_button.add_css_class("close-button")
        close_button.set_size_request(-1, 40)
        close_button.set_halign(Gtk.Align.FILL)
        close_button.connect("clicked", lambda b: self.quit())
        box.append(close_button)

        hint_label = Gtk.Label(label="Double tap ALT to Start / Stop")
        hint_label.add_css_class("hint-label")
        box.append(hint_label)

        outer.append(box)
        self.window.set_child(outer)

        css_provider = Gtk.CssProvider()
        css = """
            .app-container {
                background: rgba(30, 30, 30, 0.95);
                border-radius: 16px;
            }
            .drag-bar {
                background: rgba(255, 255, 255, 0.08);
                border-radius: 16px 16px 0 0;
                padding: 8px;
            }
            .drag-bar:hover {
                background: rgba(255, 255, 255, 0.12);
            }
            .drag-icon {
                color: rgba(255, 255, 255, 0.4);
                -gtk-icon-size: 16px;
            }
            .mic-button {
                min-width: 180px;
                min-height: 180px;
                border-radius: 50%;
                border: none;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                -gtk-icon-size: 64px;
            }
            .mic-ready { background: #3584e4; color: white; }
            .mic-ready:hover { background: #1c71d8; }
            .mic-recording { background: #e01b24; color: white; }
            .mic-recording:hover { background: #c01020; }
            .mic-processing { background: #f5c211; color: black; }
            .status-label {
                font-size: 18px;
                color: #ccc;
                font-weight: 500;
            }
            .close-button {
                min-height: 40px;
                padding: 6px 24px;
                background: rgba(255, 255, 255, 0.1);
                color: #aaa;
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 8px;
                font-size: 14px;
            }
            .close-button:hover {
                background: rgba(224, 27, 36, 0.8);
                color: white;
                border-color: transparent;
            }
            .hint-label {
                font-size: 10px;
                color: rgba(255, 255, 255, 0.35);
                margin-top: 4px;
            }
            window {
                background: transparent;
            }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            self.window.get_display(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        self.set_ready_state()
        self.window.present()

        # Set always-on-top after window is fully mapped
        GLib.timeout_add(200, self._set_always_on_top)

        # Start Alt double-tap hotkey listener
        self._start_hotkey_listener()

        # Create virtual keyboard for sending keystrokes (bypasses ydotool)
        self._init_uinput()

        # Start whisper-server (model stays in RAM for fast transcription)
        subprocess.run(["systemctl", "--user", "start", "whisper-server"],
                       check=False, capture_output=True)
        print("Whisper server started", flush=True)

    def do_shutdown(self):
        """Clean up all resources on app exit."""
        print("Shutting down...", flush=True)

        # Stop any active recording
        if self.record_process:
            self.record_process.terminate()
            try:
                self.record_process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self.record_process.kill()
            self.record_process = None

        # Stop whisper-server
        subprocess.run(["systemctl", "--user", "stop", "whisper-server"],
                       check=False, capture_output=True)
        print("Whisper server stopped", flush=True)

        # Close UInput virtual keyboard
        if self.uinput:
            try:
                self.uinput.close()
            except Exception:
                pass
            self.uinput = None

        # Close IPC server socket
        if self.ipc_server:
            try:
                self.ipc_server.close()
            except Exception:
                pass

        # Remove socket and temp files
        for f in [IPC_SOCKET, AUDIO_FILE, "/tmp/whisper_paste.txt",
                  AUDIO_FILE + ".norm.wav"]:
            try:
                os.remove(f)
            except OSError:
                pass

        print("Cleanup complete", flush=True)
        Gtk.Application.do_shutdown(self)

    def _on_drag_begin(self, gesture, start_x, start_y):
        """Store the window position when drag starts."""
        self._drag_start_x, self._drag_start_y = self.window.get_position() if hasattr(self.window, 'get_position') else (0, 0)
        # Use the native surface to begin move
        native = self.window.get_native()
        if native:
            surface = native.get_surface()
            if surface:
                gesture.set_state(Gtk.EventSequenceState.CLAIMED)
                surface.begin_move(gesture.get_device(), gesture.get_current_button(), start_x, start_y, GLib.get_monotonic_time() / 1000)

    def _on_drag_update(self, gesture, offset_x, offset_y):
        """No-op — the window manager handles the move after begin_move."""
        pass

    def _set_always_on_top(self):
        """Set window as always-on-top using xdotool + wmctrl."""
        try:
            result = subprocess.run(
                ["xdotool", "search", "--pid", str(os.getpid())],
                capture_output=True, text=True, timeout=2
            )
            for wid in result.stdout.strip().split('\n'):
                if wid:
                    subprocess.run(
                        ["wmctrl", "-i", "-r", wid, "-b", "add,above"],
                        check=False, capture_output=True, timeout=2
                    )
        except FileNotFoundError as e:
            print(f"Missing tool for always-on-top: {e}")
        except Exception as e:
            print(f"Could not set always-on-top: {e}")
        return False

    def _init_uinput(self):
        """Create a virtual keyboard for sending keystrokes directly."""
        try:
            from evdev import UInput, ecodes
            self.uinput = UInput({ecodes.EV_KEY: [
                ecodes.KEY_LEFTALT, ecodes.KEY_TAB,
                ecodes.KEY_LEFTCTRL, ecodes.KEY_LEFTSHIFT, ecodes.KEY_V
            ]}, name='whisper-dictate-kbd')
            print("UInput virtual keyboard created")
        except Exception as e:
            print(f"Could not create UInput device: {e}")
            self.uinput = None

    def _send_keys(self, keys, delay=0.05):
        """Send a key combination via UInput."""
        from evdev import ecodes
        for key in keys:
            self.uinput.write(ecodes.EV_KEY, key, 1)
        self.uinput.syn()
        time.sleep(delay)
        for key in reversed(keys):
            self.uinput.write(ecodes.EV_KEY, key, 0)
        self.uinput.syn()

    def _start_hotkey_listener(self):
        """Listen for Alt double-tap to toggle recording."""
        try:
            import evdev
            from evdev import ecodes
        except ImportError:
            print("python3-evdev not installed - Alt double-tap hotkey disabled")
            return

        def listener_thread():
            devices = []
            for path in evdev.list_devices():
                try:
                    devices.append(evdev.InputDevice(path))
                except PermissionError:
                    continue

            keyboards = [d for d in devices if ecodes.EV_KEY in d.capabilities()]
            if not keyboards:
                print("No keyboard devices found for hotkey listener")
                return

            last_alt_release = 0
            other_key_pressed = False

            while True:
                try:
                    r, _, _ = select.select(keyboards, [], [])
                    for dev in r:
                        for event in dev.read():
                            if event.type != ecodes.EV_KEY:
                                continue

                            if event.code in (ecodes.KEY_LEFTALT, ecodes.KEY_RIGHTALT):
                                if event.value == 1:  # Key down
                                    other_key_pressed = False
                                elif event.value == 0:  # Key up
                                    now = time.time()
                                    if not other_key_pressed and (now - last_alt_release) < 0.4:
                                        GLib.idle_add(self.toggle_recording)
                                        last_alt_release = 0
                                    else:
                                        last_alt_release = now
                            elif event.value == 1:  # Any other key pressed
                                other_key_pressed = True
                except Exception:
                    break

        thread = threading.Thread(target=listener_thread, daemon=True)
        thread.start()

    def start_ipc_server(self):
        """Start Unix socket server for IPC."""
        # Remove existing socket
        try:
            os.unlink(IPC_SOCKET)
        except OSError:
            pass

        def server_thread():
            server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            server.bind(IPC_SOCKET)
            server.listen(1)
            self.ipc_server = server

            while True:
                try:
                    conn, _ = server.accept()
                    data = conn.recv(1024).decode()
                    conn.close()

                    if data == "toggle":
                        # Schedule toggle on main thread
                        GLib.idle_add(self.toggle_recording)
                except:
                    break

        thread = threading.Thread(target=server_thread, daemon=True)
        thread.start()

    def toggle_recording(self):
        """Toggle recording state (called from IPC, hotkey, or button click)."""
        if not self.recording:
            self.hotkey_triggered = True
            self.start_recording()
        else:
            self.stop_recording()
        return False

    def _start_dot_animation(self, label):
        """Animate dots with fixed width — invisible dots reserve space."""
        self._anim_label = label
        self._anim_dots = 0
        # All 3 dots invisible to establish full width
        self.status_label.set_markup(
            f"{label}<span foreground='#1e1e1e'>...</span>")
        self._anim_timer = GLib.timeout_add(1000, self._tick_dots)

    def _tick_dots(self):
        """Advance the dot animation — hidden dots keep width constant."""
        self._anim_dots = (self._anim_dots % 3) + 1
        visible = "." * self._anim_dots
        hidden = 3 - self._anim_dots
        if hidden:
            self.status_label.set_markup(
                f"{self._anim_label}{visible}<span foreground='#1e1e1e'>{'.' * hidden}</span>")
        else:
            self.status_label.set_markup(f"{self._anim_label}{visible}")
        return True  # Keep timer running

    def _stop_dot_animation(self):
        """Stop the dot animation timer."""
        if hasattr(self, '_anim_timer') and self._anim_timer:
            GLib.source_remove(self._anim_timer)
            self._anim_timer = None

    def set_ready_state(self):
        self._stop_dot_animation()
        self.button.remove_css_class("mic-recording")
        self.button.remove_css_class("mic-processing")
        self.button.add_css_class("mic-ready")
        self.button.set_icon_name("audio-input-microphone-symbolic")
        self.status_label.set_text("Ready")
        return False

    def set_recording_state(self):
        self.button.remove_css_class("mic-ready")
        self.button.remove_css_class("mic-processing")
        self.button.add_css_class("mic-recording")
        self.button.set_icon_name("media-record-symbolic")
        self._start_dot_animation("Listening")

    def set_processing_state(self):
        self._stop_dot_animation()
        self.button.remove_css_class("mic-ready")
        self.button.remove_css_class("mic-recording")
        self.button.add_css_class("mic-processing")
        self.button.set_icon_name("emblem-synchronizing-symbolic")
        self._start_dot_animation("Proofing")

    def paste_text(self, text):
        """Copy to Wayland clipboard and paste instantly via Ctrl+V"""
        need_alt_tab = not self.hotkey_triggered
        self.hotkey_triggered = False
        print(f"paste_text: {len(text)} chars (need_alt_tab={need_alt_tab})", flush=True)

        def do_paste():
            try:
                env = os.environ.copy()
                env["YDOTOOL_SOCKET"] = YDOTOOL_SOCKET

                if need_alt_tab:
                    subprocess.run(["ydotool", "key", "56:1", "15:1", "15:0", "56:0"],
                                   env=env, check=False, timeout=3)
                    time.sleep(0.5)
                else:
                    time.sleep(0.3)

                # Type text with zero delays — fast burst
                subprocess.run(
                    ["ydotool", "type", "--key-delay", "2", "--key-hold", "0", "--", text],
                    env=env, check=False, timeout=120
                )
                print(f"Typed {len(text)} chars", flush=True)
            except Exception as e:
                print(f"Paste error: {e}", flush=True)

        threading.Thread(target=do_paste, daemon=True).start()

    def start_recording(self):
        self.recording = True
        self.set_recording_state()

        self.record_process = subprocess.Popen(
            ["arecord", "-f", "S16_LE", "-t", "wav", "-r", "16000", "-c", "1", AUDIO_FILE],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

    def stop_recording(self):
        self.recording = False
        self.set_processing_state()

        if self.record_process:
            self.record_process.terminate()
            self.record_process.wait()
            self.record_process = None

        GLib.timeout_add(200, self.transcribe)

    def transcribe(self):
        if not os.path.exists(AUDIO_FILE):
            self.set_ready_state()
            return False

        def do_transcribe():
            try:
                # Normalize audio levels so quiet speech is boosted before whisper
                try:
                    normalized = AUDIO_FILE + ".norm.wav"
                    subprocess.run(
                        ["ffmpeg", "-i", AUDIO_FILE, "-af", "dynaudnorm=p=0.95:s=3",
                         "-ar", "16000", "-ac", "1", "-y", normalized],
                        capture_output=True, timeout=30
                    )
                    if os.path.exists(normalized):
                        os.replace(normalized, AUDIO_FILE)
                        print("Audio normalized", flush=True)
                except (FileNotFoundError, subprocess.TimeoutExpired):
                    pass  # ffmpeg unavailable, use raw audio

                # Use whisper-server HTTP API (model preloaded in RAM)
                import urllib.request
                import json

                boundary = "----WhisperBoundary"
                with open(AUDIO_FILE, "rb") as f:
                    audio_data = f.read()

                body = (
                    f"--{boundary}\r\n"
                    f'Content-Disposition: form-data; name="file"; filename="audio.wav"\r\n'
                    f"Content-Type: audio/wav\r\n\r\n"
                ).encode() + audio_data + f"\r\n--{boundary}--\r\n".encode()

                req = urllib.request.Request(
                    WHISPER_SERVER,
                    data=body,
                    headers={"Content-Type": f"multipart/form-data; boundary={boundary}"},
                    method="POST"
                )

                t0 = time.time()
                with urllib.request.urlopen(req, timeout=300) as resp:
                    result = json.loads(resp.read().decode())

                text = result.get("text", "").strip()
                print(f"Whisper server: {len(text)} chars in {time.time()-t0:.1f}s: '{text[:200]}'", flush=True)
                GLib.idle_add(self._handle_transcription, text)
            except Exception as e:
                print(f"Transcription error: {e}", flush=True)
                GLib.idle_add(self.set_ready_state)
            finally:
                try:
                    os.remove(AUDIO_FILE)
                except OSError:
                    pass

        threading.Thread(target=do_transcribe, daemon=True).start()
        return False

    def _handle_transcription(self, text):
        """Handle transcription result on main thread."""
        self._stop_dot_animation()

        if text.lower() in HALLUCINATIONS or len(text) < 3:
            print(f"Filtered hallucination: '{text}'", flush=True)
            self.status_label.set_text("No speech detected")
            GLib.timeout_add(1500, self.set_ready_state)
            return False

        if text:
            self.paste_text(text)
            self.status_label.set_text("Done!")
            GLib.timeout_add(1500, self.set_ready_state)
        else:
            self.set_ready_state()
        return False


if __name__ == "__main__":
    # Check for --toggle with no running instance
    if "--toggle" in sys.argv and not os.path.exists(IPC_SOCKET):
        print("No running instance. Start the app first.")
        sys.exit(1)

    app = DictationApp()
    app.run(sys.argv)
