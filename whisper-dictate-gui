#!/usr/bin/env python3
"""Simple dictation GUI using whisper.cpp with hotkey support"""

import os
import sys

# Force X11 backend so we can use wmctrl to set always-on-top.
# wl-copy and ydotool still work since they're independent Wayland clients.
os.environ.setdefault('GDK_BACKEND', 'x11')

import gi
import subprocess
import time
import socket
import threading
import select

gi.require_version('Gtk', '4.0')
from gi.repository import Gtk, GLib, Gio

WHISPER_DIR = os.path.expanduser("~/.local/share/whisper.cpp")
MODEL = f"{WHISPER_DIR}/models/ggml-tiny.en.bin"
WHISPER_BIN = f"{WHISPER_DIR}/build/bin/whisper-cli"
AUDIO_FILE = "/tmp/dictation_audio.wav"
YDOTOOL_SOCKET = os.path.expanduser("~/.ydotool_socket")
IPC_SOCKET = "/tmp/whisper-dictate.sock"

# Common whisper hallucinations from silence/noise - filter these out
HALLUCINATIONS = {
    "you", "thank you", "thanks", "bye", "okay", "so", "the", "and",
    "i", "a", "to", "it", "is", "that", "for", "on", "are", "as",
    "you.", "thank you.", "thanks.", "bye.", "okay.",
    "[music]", "[blank_audio]", "(music)", "[silence]",
}

# Terminal app names that need Ctrl+Shift+V
TERMINAL_APPS = {"gnome-terminal-server", "gnome-terminal", "konsole", "xterm",
    "terminator", "tilix", "alacritty", "kitty", "wezterm", "urxvt",
    "xfce4-terminal", "lxterminal", "mate-terminal", "terminology"}


def send_toggle_command():
    """Send toggle command to running instance."""
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(IPC_SOCKET)
        sock.send(b"toggle")
        sock.close()
        return True
    except (socket.error, FileNotFoundError):
        return False


def get_active_window_name():
    """Get active window name using wmctrl or fallback"""
    try:
        result = subprocess.run(
            ["bash", "-c", """
            for wid in $(xdotool search --onlyvisible --name ""); do
                if xprop -id $wid 2>/dev/null | grep -q "_NET_WM_STATE_FOCUSED"; then
                    xdotool getwindowname $wid 2>/dev/null
                    exit 0
                fi
            done
            cat /proc/$(xdotool getactivewindow getwindowpid 2>/dev/null)/comm 2>/dev/null || echo "unknown"
            """],
            capture_output=True, text=True, timeout=2
        )
        return result.stdout.strip() or "unknown"
    except:
        return "unknown"


def is_terminal(window_name):
    """Check if window name suggests a terminal"""
    if not window_name:
        return False
    wl = window_name.lower()
    return any(t in wl for t in TERMINAL_APPS) or "terminal" in wl or "~" in window_name or window_name.endswith("$") or "@" in window_name


class DictationApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.local.whisper-dictate",
                         flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE)
        self.recording = False
        self.record_process = None
        self.window = None
        self.button = None
        self.status_label = None
        self.target_is_terminal = False
        self.ipc_server = None
        self.hotkey_triggered = False
        self.uinput = None

    def do_command_line(self, command_line):
        args = command_line.get_arguments()

        if "--toggle" in args:
            # Send toggle to running instance
            if send_toggle_command():
                print("Toggle sent to running instance")
                return 0
            else:
                print("No running instance found, starting new one...")

        self.activate()
        return 0

    def do_activate(self):
        if self.window:
            self.window.present()
            return

        # Start IPC server
        self.start_ipc_server()

        self.window = Gtk.ApplicationWindow(application=self)
        self.window.set_title("")
        self.window.set_default_size(300, 380)
        self.window.set_resizable(False)
        self.window.set_decorated(False)

        outer = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        outer.add_css_class("app-container")

        # Drag bar at the top
        drag_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        drag_bar.set_size_request(-1, 36)
        drag_bar.add_css_class("drag-bar")
        drag_icon = Gtk.Image.new_from_icon_name("open-menu-symbolic")
        drag_icon.add_css_class("drag-icon")
        drag_bar.set_halign(Gtk.Align.FILL)
        drag_bar.set_valign(Gtk.Align.START)
        # Center the drag icon
        drag_bar.append(Gtk.Box(hexpand=True))
        drag_bar.append(drag_icon)
        drag_bar.append(Gtk.Box(hexpand=True))

        # Enable dragging on the bar
        drag_gesture = Gtk.GestureDrag()
        drag_gesture.connect("drag-begin", self._on_drag_begin)
        drag_gesture.connect("drag-update", self._on_drag_update)
        drag_bar.add_controller(drag_gesture)

        outer.append(drag_bar)

        # Main content
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        box.set_halign(Gtk.Align.CENTER)
        box.set_valign(Gtk.Align.CENTER)
        box.set_vexpand(True)
        box.set_margin_top(20)
        box.set_margin_bottom(20)
        box.set_margin_start(30)
        box.set_margin_end(30)

        self.button = Gtk.Button()
        self.button.set_icon_name("audio-input-microphone-symbolic")
        self.button.add_css_class("circular")
        self.button.add_css_class("mic-button")
        self.button.set_size_request(180, 180)
        self.button.set_sensitive(False)
        box.append(self.button)

        self.status_label = Gtk.Label(label="Ready")
        self.status_label.add_css_class("status-label")
        box.append(self.status_label)

        close_button = Gtk.Button(label="Close")
        close_button.add_css_class("close-button")
        close_button.set_size_request(-1, 40)
        close_button.set_halign(Gtk.Align.FILL)
        close_button.connect("clicked", lambda b: self.quit())
        box.append(close_button)

        hint_label = Gtk.Label(label="Double tap ALT to Start / Stop")
        hint_label.add_css_class("hint-label")
        box.append(hint_label)

        outer.append(box)
        self.window.set_child(outer)

        css_provider = Gtk.CssProvider()
        css = """
            .app-container {
                background: rgba(30, 30, 30, 0.95);
                border-radius: 16px;
            }
            .drag-bar {
                background: rgba(255, 255, 255, 0.08);
                border-radius: 16px 16px 0 0;
                padding: 8px;
            }
            .drag-bar:hover {
                background: rgba(255, 255, 255, 0.12);
            }
            .drag-icon {
                color: rgba(255, 255, 255, 0.4);
                -gtk-icon-size: 16px;
            }
            .mic-button {
                min-width: 180px;
                min-height: 180px;
                border-radius: 50%;
                border: none;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                -gtk-icon-size: 64px;
            }
            .mic-ready { background: #3584e4; color: white; }
            .mic-ready:hover { background: #1c71d8; }
            .mic-recording { background: #e01b24; color: white; }
            .mic-recording:hover { background: #c01020; }
            .mic-processing { background: #f5c211; color: black; }
            .status-label {
                font-size: 18px;
                color: #ccc;
                font-weight: 500;
            }
            .close-button {
                min-height: 40px;
                padding: 6px 24px;
                background: rgba(255, 255, 255, 0.1);
                color: #aaa;
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 8px;
                font-size: 14px;
            }
            .close-button:hover {
                background: rgba(224, 27, 36, 0.8);
                color: white;
                border-color: transparent;
            }
            .hint-label {
                font-size: 10px;
                color: rgba(255, 255, 255, 0.35);
                margin-top: 4px;
            }
            window {
                background: transparent;
            }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            self.window.get_display(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        self.set_ready_state()
        self.window.present()

        # Set always-on-top after window is fully mapped
        GLib.timeout_add(200, self._set_always_on_top)

        # Start Alt double-tap hotkey listener
        self._start_hotkey_listener()

        # Create virtual keyboard for sending keystrokes (bypasses ydotool)
        self._init_uinput()

    def _on_drag_begin(self, gesture, start_x, start_y):
        """Store the window position when drag starts."""
        self._drag_start_x, self._drag_start_y = self.window.get_position() if hasattr(self.window, 'get_position') else (0, 0)
        # Use the native surface to begin move
        native = self.window.get_native()
        if native:
            surface = native.get_surface()
            if surface:
                gesture.set_state(Gtk.EventSequenceState.CLAIMED)
                surface.begin_move(gesture.get_device(), gesture.get_current_button(), start_x, start_y, GLib.get_monotonic_time() / 1000)

    def _on_drag_update(self, gesture, offset_x, offset_y):
        """No-op — the window manager handles the move after begin_move."""
        pass

    def _set_always_on_top(self):
        """Set window as always-on-top using xdotool + wmctrl."""
        try:
            result = subprocess.run(
                ["xdotool", "search", "--pid", str(os.getpid())],
                capture_output=True, text=True, timeout=2
            )
            for wid in result.stdout.strip().split('\n'):
                if wid:
                    subprocess.run(
                        ["wmctrl", "-i", "-r", wid, "-b", "add,above"],
                        check=False, capture_output=True, timeout=2
                    )
        except FileNotFoundError as e:
            print(f"Missing tool for always-on-top: {e}")
        except Exception as e:
            print(f"Could not set always-on-top: {e}")
        return False

    def _init_uinput(self):
        """Create a virtual keyboard for sending keystrokes directly."""
        try:
            from evdev import UInput, ecodes
            self.uinput = UInput({ecodes.EV_KEY: [
                ecodes.KEY_LEFTALT, ecodes.KEY_TAB,
                ecodes.KEY_LEFTCTRL, ecodes.KEY_LEFTSHIFT, ecodes.KEY_V
            ]}, name='whisper-dictate-kbd')
            print("UInput virtual keyboard created")
        except Exception as e:
            print(f"Could not create UInput device: {e}")
            self.uinput = None

    def _send_keys(self, keys, delay=0.05):
        """Send a key combination via UInput."""
        from evdev import ecodes
        for key in keys:
            self.uinput.write(ecodes.EV_KEY, key, 1)
        self.uinput.syn()
        time.sleep(delay)
        for key in reversed(keys):
            self.uinput.write(ecodes.EV_KEY, key, 0)
        self.uinput.syn()

    def _start_hotkey_listener(self):
        """Listen for Alt double-tap to toggle recording."""
        try:
            import evdev
            from evdev import ecodes
        except ImportError:
            print("python3-evdev not installed - Alt double-tap hotkey disabled")
            return

        def listener_thread():
            devices = []
            for path in evdev.list_devices():
                try:
                    devices.append(evdev.InputDevice(path))
                except PermissionError:
                    continue

            keyboards = [d for d in devices if ecodes.EV_KEY in d.capabilities()]
            if not keyboards:
                print("No keyboard devices found for hotkey listener")
                return

            last_alt_release = 0
            other_key_pressed = False

            while True:
                try:
                    r, _, _ = select.select(keyboards, [], [])
                    for dev in r:
                        for event in dev.read():
                            if event.type != ecodes.EV_KEY:
                                continue

                            if event.code in (ecodes.KEY_LEFTALT, ecodes.KEY_RIGHTALT):
                                if event.value == 1:  # Key down
                                    other_key_pressed = False
                                elif event.value == 0:  # Key up
                                    now = time.time()
                                    if not other_key_pressed and (now - last_alt_release) < 0.4:
                                        GLib.idle_add(self.toggle_recording)
                                        last_alt_release = 0
                                    else:
                                        last_alt_release = now
                            elif event.value == 1:  # Any other key pressed
                                other_key_pressed = True
                except Exception:
                    break

        thread = threading.Thread(target=listener_thread, daemon=True)
        thread.start()

    def start_ipc_server(self):
        """Start Unix socket server for IPC."""
        # Remove existing socket
        try:
            os.unlink(IPC_SOCKET)
        except OSError:
            pass

        def server_thread():
            server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            server.bind(IPC_SOCKET)
            server.listen(1)
            self.ipc_server = server

            while True:
                try:
                    conn, _ = server.accept()
                    data = conn.recv(1024).decode()
                    conn.close()

                    if data == "toggle":
                        # Schedule toggle on main thread
                        GLib.idle_add(self.toggle_recording)
                except:
                    break

        thread = threading.Thread(target=server_thread, daemon=True)
        thread.start()

    def toggle_recording(self):
        """Toggle recording state (called from IPC, hotkey, or button click)."""
        if not self.recording:
            self.hotkey_triggered = True
            self.start_recording()
        else:
            self.stop_recording()
        return False

    def set_ready_state(self):
        self.button.remove_css_class("mic-recording")
        self.button.remove_css_class("mic-processing")
        self.button.add_css_class("mic-ready")
        self.button.set_icon_name("audio-input-microphone-symbolic")
        self.status_label.set_text("Ready")
        return False

    def set_recording_state(self):
        self.button.remove_css_class("mic-ready")
        self.button.remove_css_class("mic-processing")
        self.button.add_css_class("mic-recording")
        self.button.set_icon_name("media-record-symbolic")
        self.status_label.set_text("Recording...")

    def set_processing_state(self):
        self.button.remove_css_class("mic-ready")
        self.button.remove_css_class("mic-recording")
        self.button.add_css_class("mic-processing")
        self.button.set_icon_name("emblem-synchronizing-symbolic")
        self.status_label.set_text("Processing...")

    def paste_text(self, text):
        """Copy to clipboard and paste in a background thread"""
        need_alt_tab = not self.hotkey_triggered
        self.hotkey_triggered = False
        print(f"paste_text called with: '{text}' (need_alt_tab={need_alt_tab})", flush=True)

        def do_paste():
            try:
                print("do_paste thread started", flush=True)
                env = os.environ.copy()
                env["YDOTOOL_SOCKET"] = YDOTOOL_SOCKET

                if need_alt_tab:
                    # Button click stole focus — Alt+Tab back to previous window
                    print("Sending Alt+Tab to return focus...", flush=True)
                    subprocess.run(["ydotool", "key", "56:1", "15:1", "15:0", "56:0"], env=env, check=False, timeout=3)
                    time.sleep(0.5)
                else:
                    # Hotkey triggered — target window still has focus
                    time.sleep(0.3)

                # Type the text directly via ydotool (avoids clipboard X11/Wayland mismatch)
                print(f"Typing text via ydotool...", flush=True)
                subprocess.run(["ydotool", "type", "--", text], env=env, check=False, timeout=10)
                print("Paste complete", flush=True)
            except Exception as e:
                import traceback
                print(f"Paste error: {e}", flush=True)
                traceback.print_exc()

        try:
            t = threading.Thread(target=do_paste, daemon=True)
            t.start()
            print(f"Paste thread started: {t.name}", flush=True)
        except Exception as e:
            print(f"Failed to start paste thread: {e}", flush=True)

    def start_recording(self):
        self.recording = True
        self.set_recording_state()

        self.record_process = subprocess.Popen(
            ["arecord", "-f", "cd", "-t", "wav", "-r", "16000", "-c", "1", AUDIO_FILE],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

    def stop_recording(self):
        self.recording = False
        self.set_processing_state()

        if self.record_process:
            self.record_process.terminate()
            self.record_process.wait()
            self.record_process = None

        GLib.timeout_add(200, self.transcribe)

    def transcribe(self):
        if not os.path.exists(AUDIO_FILE):
            self.set_ready_state()
            return False

        try:
            result = subprocess.run(
                [WHISPER_BIN, "-m", MODEL, "-f", AUDIO_FILE,
                 "--no-timestamps", "-nt", "-np"],
                capture_output=True,
                text=True
            )
            text = result.stdout.strip()

            print(f"Whisper output: '{text}'")

            # Filter out common hallucinations from silence
            if text.lower() in HALLUCINATIONS or len(text) < 3:
                print(f"Filtered hallucination: '{text}'")
                self.status_label.set_text("No speech detected")
                GLib.timeout_add(1500, self.set_ready_state)
                return False

            if text:
                self.paste_text(text)
                self.status_label.set_text("Done!")
                GLib.timeout_add(1500, self.set_ready_state)
            else:
                self.set_ready_state()

        except Exception as e:
            print(f"Error: {e}")
            self.set_ready_state()
        finally:
            if os.path.exists(AUDIO_FILE):
                os.remove(AUDIO_FILE)

        return False


if __name__ == "__main__":
    # Check for --toggle with no running instance
    if "--toggle" in sys.argv and not os.path.exists(IPC_SOCKET):
        print("No running instance. Start the app first.")
        sys.exit(1)

    app = DictationApp()
    app.run(sys.argv)
